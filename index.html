<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ChattingTerminalors</title>
<link rel="icon" type="image/x-icon" href="logo.ico?v=6">

<style>
/* 1. RESET & FONT */
@font-face {
  font-family: Retro;
  src: url("retro.ttf");
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
  background: black;
  color: #aaa;
  font-family: Retro, monospace;
  height: 100vh;
  width: 100vw;
  display: flex;
  overflow: hidden;
}

/* 2. LOADING SCREEN */
#loading {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: black;
  color: #00ff00;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 24px;
  z-index: 10000;
}

/* 3. SIDEBAR (USERS) */
#users {
  width: 220px;
  min-width: 220px;
  height: 100%;
  border-right: 1px solid #333;
  padding: 10px;
  overflow-y: auto;
  background: #050505;
  display: none; 
}

#users h2 {
  font-size: 14px;
  color: #666;
  margin-top: 0;
  border-bottom: 1px solid #333;
  padding-bottom: 5px;
}

.user {
  font-size: 13px;
  margin-bottom: 5px;
}

/* 4. TERMINAL AREA */
#terminal {
  flex: 1;
  position: relative;
  height: 100%;
  background: black;
  display: none; 
  flex-direction: column;
}

#output {
  flex: 1;
  padding: 15px;
  padding-bottom: 60px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

/* 5. INPUT BAR */
#input {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 50px;
  background: #111;
  border: none;
  border-top: 2px solid #00ff00;
  color: #00ff00;
  padding: 15px;
  font-family: Retro, monospace;
  font-size: 16px;
  outline: none;
  z-index: 9999;
}

/* RAINBOW ANIMATION */
@keyframes rainbow {
  0% { color: #ff0000; }
  25% { color: #ffff00; }
  50% { color: #00ff00; }
  75% { color: #00ffff; }
  100% { color: #ff0000; }
}

.rainbow-name {
  animation: rainbow 3s linear infinite;
  font-weight: bold;
  text-shadow: 0 0 5px rgba(255,255,255,0.2);
}

/* LINK STYLING */
.chat-link {
  color: #55aaff;
  text-decoration: underline;
  cursor: pointer;
}

#typing-indicator {
  position: absolute;
  bottom: 55px;
  left: 15px;
  font-size: 12px;
  color: #666;
  font-style: italic;
  pointer-events: none;
  z-index: 10;
}

.dot {
  animation: dotPulse 1.5s infinite;
  display: inline-block;
}

@keyframes dotPulse {
  0% { opacity: 0; }
  50% { opacity: 1; }
  100% { opacity: 0; }
}
  
/* TIMESTAMP & TAG STYLING */
.timestamp {
  color: #555;
  font-size: 12px;
  margin-right: 8px;
}

.owner-tag {
  color: #ff0000;
  font-weight: bold;
  margin-left: 5px;
  font-size: 10px;
  vertical-align: middle;
}
</style>
</head>

<body>

<div id="loading">Loading... |</div>

<div id="users">
  <h2>USERS</h2>
  <div id="userList"></div>
</div>

<div id="terminal">
  <div id="output">
ChattingTerminalors
-------------------
Global terminal chat
Type /help for commands
  <div>
  <input id="input" placeholder="> type here... and whats your favorite snack?" autocomplete="off">
</div>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyBHQIBxspDo0eF5aDA80FMziFB9Oo03jC8",
  authDomain: "chattingterminalors.firebaseapp.com",
  databaseURL: "https://chattingterminalors-default-rtdb.firebaseio.com",
  projectId: "chattingterminalors",
  storageBucket: "chattingterminalors.firebasestorage.app",
  messagingSenderId: "913059668390",
  appId: "1:913059668390:web:f4f4987bbe41e1f51e6f67"
};

if (!firebase.apps.length) {
    firebase.initializeApp(firebaseConfig);
}
const db = firebase.database();

const output = document.getElementById("output");
const input = document.getElementById("input");
const userList = document.getElementById("userList");
const loadingScreen = document.getElementById("loading");
const usersDiv = document.getElementById("users");
const terminalDiv = document.getElementById("terminal");

const badWords = ["fuck","shit","bitch","asshole","damn","pussy","sex","nya","cum","sexy","agentsexbox","nigga","niger","nigger"];
const launchDate = new Date("2026-02-10T00:00:00").getTime(); 

let isLockdownActive = false;

/* ---------- LOADING ANIMATION ---------- */
let loadFrame = 0;
const loadChars = ["|", "/", "-"];
const loadInterval = setInterval(() => {
  loadingScreen.textContent = "Loading... " + loadChars[loadFrame];
  loadFrame = (loadFrame + 1) % loadChars.length;
}, 700);

function hideLoading() {
  if (loadingScreen.style.display !== "none") {
    clearInterval(loadInterval);
    loadingScreen.style.display = "none";
    usersDiv.style.display = "block";
    terminalDiv.style.display = "flex";
  }
}

/* ---------- SECURITY: ESCAPE HTML ---------- */
function escapeHTML(str) {
  const p = document.createElement("p");
  p.textContent = str;
  return p.innerHTML;
}

/* ---------- UTILS ---------- */
function censor(text) {
  badWords.forEach(w => {
    text = text.replace(new RegExp(w, "gi"), "####");
  });
  return text;
}

function randomColor() {
  return `hsl(${Math.random()*360},70%,60%)`;
}

function getFormattedTime(timestamp) {
  const date = timestamp ? new Date(timestamp) : new Date();
  const hrs = date.getHours().toString().padStart(2, '0');
  const mins = date.getMinutes().toString().padStart(2, '0');
  return `[${hrs}:${mins}]`;
}

function botMsg(text) {
  const line = document.createElement("div");
  line.style.margin = "2px 0";
  const time = getFormattedTime();
  // Safe bot message rendering
  line.innerHTML = `<span class="timestamp">${time}</span><span style="color:#00ff00">System32 [/]</span>: ${escapeHTML(text).replace(/\n/g, '<br>')}`;
  output.appendChild(line);
  output.scrollTop = output.scrollHeight;
}

function formatUptime(ms) {
  if (ms < 0) ms = 0; 
  const seconds = Math.floor((ms / 1000) % 60);
  const minutes = Math.floor((ms / (1000 * 60)) % 60);
  const hours = Math.floor((ms / (1000 * 60 * 60)) % 24);
  const days = Math.floor(ms / (1000 * 60 * 60 * 24));
  return `${days} days, ${hours} hours, ${minutes} minutes`;
}

/* ---------- LINK LOGIC ---------- */
function parseMessage(text) {
  let safeText = escapeHTML(text);
  const urlRegex = /(https?:\/\/[^\s]+)/g;
  return safeText.replace(urlRegex, (url) => {
    return `<a href="${url}" target="_blank" class="chat-link">${url}</a>`;
  });
}

/* ---------- LOGIN ---------- */
let username = localStorage.getItem("ct_username");
let color = localStorage.getItem("ct_color");

if (!username || username.includes("/")) {
  username = prompt("Enter username:");
  if (!username || username.includes("/")) {
    username = "guest" + Math.floor(Math.random()*1000);
  }
  color = randomColor();
  localStorage.setItem("ct_username", username);
  localStorage.setItem("ct_color", color);
}

const userRef = db.ref("chattingterminalors/users").push();
userRef.set({ name: username, color: color });
userRef.onDisconnect().remove();

/* ---------- DATA HANDLERS ---------- */

// ðŸ”’ LOCKDOWN LISTENER
db.ref("chattingterminalors/settings/lockdown").on("value", snap => {
  isLockdownActive = !!snap.val();
  if (isLockdownActive) {
    if (username !== "ðŸ‘‘AgentXboxðŸ‘‘") {
      input.style.display = "none";
    }
  } else {
    input.style.display = "block";
  }
});

db.ref("chattingterminalors/users").on("value", snap => {
  hideLoading();
  userList.innerHTML = "";
  const botDiv = document.createElement("div");
  botDiv.className = "user";
  botDiv.style.color = "#00ff00";
  botDiv.textContent = "System32 [/]";
  userList.appendChild(botDiv);

  snap.forEach(child => {
    const u = child.val();
    const div = document.createElement("div");
    div.className = "user";
    if (u.color === "rainbow") div.classList.add("rainbow-name");
    else div.style.color = u.color;
    div.textContent = u.name;
    if (u.name === "ðŸ‘‘AgentXboxðŸ‘‘") {
      const tag = document.createElement("span");
      tag.className = "owner-tag";
      tag.textContent = " [OWNER]";
      div.appendChild(tag);
    }
    userList.appendChild(div);
  });
});

db.ref("chattingterminalors/messages")
  .limitToLast(100)
  .on("child_added", snap => {
    const m = snap.val();
    const line = document.createElement("div");
    line.style.marginBottom = "2px";
    const timeStr = getFormattedTime(m.time);
    const safeName = escapeHTML(m.name);
    let nameTag = (m.color === "rainbow") 
      ? `<span class="rainbow-name">${safeName}</span>` 
      : `<span style="color:${m.color}">${safeName}</span>`;
    let ownerLabel = (m.name === "ðŸ‘‘AgentXboxðŸ‘‘") ? `<span class="owner-tag">[OWNER]</span>` : "";
    const formattedText = parseMessage(m.text);
    line.innerHTML = `<span class="timestamp">${timeStr}</span>${nameTag}${ownerLabel}: ${formattedText}`;
    output.appendChild(line);
    output.scrollTop = output.scrollHeight;
  });

/* ---------- INPUT ---------- */
input.addEventListener("keydown", e => {
  if (e.key === "Enter" && input.value.trim()) {
    const val = input.value.trim();
    
    // RESTORED FULL COMMAND LOGIC
    if (val === "/help") {
      botMsg(
        "/help - shows this message\n" +
        "/color [color] - set your username color (or 'rainbow')\n" +
        "/name [new username] - set a new username for you.\n" +
        "/info - see info of website.\n" +
        "/uptime - shows how long the website is public.\n" +
        "/clear - clear all messages (local)\n" +
        "/reset - resets your connection.\n" +
        (username === "ðŸ‘‘AgentXboxðŸ‘‘" ? "/lockdown - Toggle chat restriction.\n" : "") +
        "\nBot officially created by Agentxbox, Createz."
      );
    } 
    else if (val === "/lockdown" && username === "ðŸ‘‘AgentXboxðŸ‘‘") {
      const newState = !isLockdownActive;
      db.ref("chattingterminalors/settings/lockdown").set(newState);
      if (newState) {
        db.ref("chattingterminalors/messages").push({
          name: "System32 [/]",
          color: "#00ff00",
          text: "The chat has been locked down due to maintenance.",
          time: Date.now()
        });
      } else {
        botMsg("Lockdown lifted. Everyone can chat again.");
      }
    }
    else if (val === "/info") {
      botMsg("ChattingTerminalors built in HTML and CSS and JS with Google Firebase and Github Pages.");
    }
    else if (val === "/uptime") {
      const diff = Date.now() - launchDate;
      botMsg("Website Uptime: " + formatUptime(diff));
    }
    else if (val === "/clear") {
      output.innerHTML = "ChattingTerminalors\n-------------------\nGlobal terminal chat\nType /help for commands\n";
    }
    else if (val === "/reset") {
      botMsg("Resetting connection...");
      setTimeout(() => location.reload(), 1000);
    }
    else if (val.startsWith("/color ")) {
      const newCol = val.split(" ")[1];
      if(newCol) {
        color = newCol;
        localStorage.setItem("ct_color", color);
        userRef.update({ color: color });
        botMsg("Your color has been changed to " + newCol + ".");
      }
    }
    else if (val.startsWith("/name ")) {
      const parts = val.split(" ");
      const newName = parts.slice(1).join(" ");
      if (!newName || newName.includes("/")) {
          botMsg("Invalid name.");
      } else {
          db.ref("chattingterminalors/users").once("value", snap => {
            let taken = false;
            snap.forEach(child => {
              if (child.val().name?.toLowerCase() === newName.toLowerCase()) taken = true;
            });
            if (taken) {
              botMsg("Error: That username is already taken by someone else.");
            } else {
              username = newName;
              localStorage.setItem("ct_username", username);
              userRef.update({ name: username });
              botMsg("Your username has been changed to " + newName + ".");
            }
          });
      }
    }
    else {
      db.ref("chattingterminalors/messages").push({
        name: username,
        color: color,
        text: censor(val),
        time: Date.now()
      });
    }
    input.value = "";
  }
});

/* FIXED: This links your escape function to the typing logic */
const sanitize = escapeHTML; 

/* ---------- GLOBAL TYPING INDICATOR ---------- */
const typingIndicator = document.getElementById("typing-indicator");
const typingRef = db.ref("chattingterminalors/typing");

// 1. Send your status to the Global Database
input.addEventListener("input", () => {
  if (userRef && userRef.key) {
    if (input.value.length > 0) {
      typingRef.child(userRef.key).set({ 
        name: username, 
        color: color 
      });
      
      // Auto-remove after 3 seconds of silence
      clearTimeout(window.typingTimeout);
      window.typingTimeout = setTimeout(() => {
        if(userRef) typingRef.child(userRef.key).remove();
      }, 3000);
    } else {
      typingRef.child(userRef.key).remove();
    }
  }
});

// 2. Remove status when you click away or send
input.addEventListener("blur", () => {
  if (userRef && userRef.key) typingRef.child(userRef.key).remove();
});

// 3. Listen for EVERYONE ELSE in the world
typingRef.on("value", snap => {
  const typers = [];
  snap.forEach(child => {
    // CRITICAL: This line hides YOUR name from YOUR screen
    if (userRef && child.key !== userRef.key) { 
      const data = child.val();
      const safeName = sanitize(data.name);
      typers.push(`<span style="color:${data.color}">${safeName}</span>`);
    }
  });

  if (typers.length > 0) {
    let text = typers.join(", ");
    text += typers.length > 1 ? " are typing" : " is typing";
    typingIndicator.innerHTML = `${text} <span class="dot">.</span><span class="dot" style="animation-delay:0.2s">.</span><span class="dot" style="animation-delay:0.4s">.</span>`;
  } else {
    typingIndicator.innerHTML = "";
  }
});
  
</script>

</body>
</html>
